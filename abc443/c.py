# この問題はイベント駆動型シミュレーション。
# 秒ごとに回すのではなく、
# 「青木が通る時刻」と「再オープン時刻」だけを処理する。
#
# s : 次にchokutterを開く時刻
# i : 次に処理する青木のインデックス
# 各ループで「1回の開いている区間」を計算する。

#入力処理部分
N, T = map(int, input().split())



#通りかかった秒数のリスト
A = list(map(int, input().split()))if N > 0 else[]

#今見ているchukutterの開始時刻
s = 0
#配列のi番目
i = 0
#開いている時間を足していく
ans = 0

#iごとでループまわす，配列Aの値を一個ずつみていく
while s < T:
  
  #開いていない間に来た青木は無視して，開いているときに来たら以下の処理に進む
  while i < N and A[i] < s:
    i += 1
  
  #最後の青木だったらansを計算してループおわり
  if i == N:
    ans += T - s
    break
  
  #次の青木が来る時刻
  a = A[i]
  
  #終業後に来るなら終業まで見て終わり
  if a >= T:
    ans += T - s
    break
  
  #mainのところは以下
  #sからaまで見ている
  ans += a - s
  
  #aで閉じたので100秒後にまた開く
  s = a + 100
  
  #次の青木の時間へ
  i += 1
  
print(ans)
